---
layout : post
title : Sequelize 정리
subtitle : sequelize
categories : development
tags : mysql
comments : false
---

# Sequelize
시퀄라이즈는 MySQL 작업을 쉽게 할 수 있도록 도와주는 라이브러리다.

시퀄라이즈는 ORM으로 분류된다.

ORM (Object Relational Mapping) 은 자바스크립트의 객체와 데이터베이스의 릴레이션을 매핑해주는 도구이다.

# 관계 정의하기
users 테이블과 comments 테이블의 관계는 일대다이다.

사용자가 일, 댓글이 다이다.

하나의 댓글에 사용자가 여러명일 수는 없지만, 하나의 사용자는 여러 댓글을 달 수 있기 때문이다.

다른 관계로는 일대일, 다대다 관계가 있다.

일대일 관계는 사용자 테이블과 사용자 정보 테이블의 관계와 같다. 하나의 사용자에 여러 사용자 정보가 존재하지는 않기 때문이다.

다대다 관계는 게시글 테이블과 해시태그 테이블의 관계와 같다.

MySQL에서는 JOIN이라는 기능으로 테이블 간의 관계를 파악해 결과를 도출한다. 시퀄라이즈는 JOIN 기능도 알아서 구현해준다.

# 시퀄라이즈에서의 표현 방법
1. 1:N - hasMany 메소드로 표현한다. users 테이블의 로우 하나를 불러올 때 연결된 comments 테이블의 로우들도 같이 불러올 수 있다. 반대로 belongsTo 메소드도 있다. comment 테이블의 로우를 불러올 때 연결된 users 테이블의 로우를 불러온다.
2. 1:1 - hasOne 메소드를 사용한다. 사용자 정보를 담고 있는 Info 모델이 있다고 하면 아래와 같이 표현할 수 있다.

    db.User.hasOne(db.info, {foreignKey : 'user_id', sourceKey : 'id'});

    db.User.belongsTo(db.User, {foreignKey : 'user_id', targetKey : 'id'});

3. N:M - belongsToMany 메소드를 사용한다. N:M 관계 특성상 새로운 모델이 생성되는데, through 속성에 그 이름을 적어주면 된다. 해당 모델에는 N과 M의 아이디가 저장된다. 게시글 정보를 담고 있는 Post 모델과 해시태그 정보를 담고 있는 Hashtag 모델이 있다고 하면 다음과 같이 표현할 수 있다.

    db.Post.belongsToMany(db.Hashtag, {through : 'PostHashtag'});

    db.User.belongsToMany(db.Post, {through : 'PostHashtag'});

    이 경우 PostHashtag에 게시물과 해시태그의 아이디가 저장되는 것이다.

    N:M 관계에서는 데이터를 조회할 때 여러 단계를 거쳐야 한다. 해시태그를 사용하여 게시물을 조회하는 경우를 생각해보면, 해시태그를 Hashtag 모델에서 조회하고, 가져온 해시태그의 아이디를 바탕으로 PostHashtag 모델에서 해시태그 아이디가 같은 게시물들을 찾아서 Post 모델에서 게시물 정보를 가져오는 것이다.

    시퀄라이즈는 이 과정을 편리하게 할 수 있도록 몇 가지 메소드를 지원한다.

    해시태그를 찾으면 그 해시태그에서 바로 getPosts 메소드를 사용할 수 있는데, 메소드의 이름은 get + 모델 이름의 복수형 으로 만들어진다.

# 자료형
시퀄라이즈의 자료형은 MySQL과 다른 경우가 있기 때문에 숙지해야 한다.

A - B : A와 B가 대응 관계라는 뜻.
A : MySQL 자료형
B : 시퀄라이즈 자료형

- VARCHAR - STRING
- INT - INTEGER
- TINYINT - BOOLEAN
- INT UNSIGNED - INTEGER.UNSIGNED
- DATETIME - DATE

# 컬럼 옵션

A - B : A와 B가 대응 관계라는 뜻.
A : MySQL 옵션
B : 시퀄라이즈 옵션

- NULL, NOT NULL - allowNull
- UNIQUE - unique
- DEFAULT - defaultValue

# 테이블 옵션
define 메소드의 세 번째 인자이다.

- timestamps : 이 옵션이 true이면 시퀄라이즈는 createdAt과 updatedAt 컬럼을 추가한다. RAW가 생성될 때, 수정될 때의 시간이 자동으로 입력된다.
- paranoid : 이 옵션이 true이면 deletedAt이라는 컬럼이 추가된다. RAW를 삭제하는 시퀄라이즈 명령을 내렸을 때 RAW를 제거하는 대신 deletedAt에 제거된 날짜를 입력한다. RAW를 조회하는 명령을 내렸을 때는 deletedAt의 값이 null인 RAW를 조회한다. 이러한 옵션은 데이터 복구를 가능하게 한다.
- underscored : 이 옵션은 timestamps와 paranoid가 만들어주는 createdAt, updatedAt, deletedAt을 각각 created_at, updated_at, deleted_at으로 바꾸어준다. 이렇게 단어의 구분을 할 때 대문자 대신 _를 사용하는 것을 스네이크케이스 형식이라고 한다.
- tableName : 이 옵션은 테이블 이름을 다른 것으로 설정하고 싶을 때 사용한다. 시퀄라이즈는 자동으로 define 메소드의 첫 번째 인자를 복수형으로 만들어 사용한다. 이러한 자동 변환을 막고 싶을 때 tableName 옵션에 값을 주면 된다.

# 시퀄라이즈 쿼리
시퀄라이즈로 CRUD 작업을 하려면 시퀄라이즈 쿼리를 알아야 한다. SQL 문을 자바스크립트로 생성하는 시퀄라이즈만의 방식이 있다.

쿼리는 프로미스를 반환하므로 then을 붙여 결괏값을 받을 수 있고, async await와 사용할 수도 있다.

# CREATE
INSERT INTO nodejs.users (name, age, married, comment) VALUES ('zero', 24, 0, '자기소개1');

위 SQL문은 아래의 코드와 같다.
```javascript
const {User} = require('models 폴더 경로');
User.create({
    name : 'zero',
    age : 24,
    married : false,
    comment : '자기소개1',
});
```
주의할 점은 시퀄라이즈의 자료형에 맞춰서 값을 넣어야 한다는 것이다. 이것이 married가 0이 아니고 false였던 이유이고, 시퀄라이즈가 MySQL에 맞춰서 알아서 넣어준다.

# READ
SELECT * FROM nodejs.users;

위 SQL문은 아래의 코드와 같다.
```javascript
User.findAll({});
```

SELECT * FROM nodejs.users LIMIT 1;

위 SQL문은 아래의 코드와 같다.
```javascript
User.find({});
```
여러 개 가져올 때는 findAll, 하나만 가져올 때는 find를 사용하면 된다.

SELECT name, married FROM nodejs.users;

위 SQL문은 아래의 코드와 같다.
```javascript
User.findAll({
    attributes : ['name', 'married'],
});
```
위처럼 attributes 옵션을 사용해서 원하는 컬럼만 가져올 수도 있다.

SELECT name, age FROM nodejs.users WHERE married = 1 AND age > 30;

위 SQL문은 아래의 코드와 같다.
```javascript
const {User, Sequelize : {Op}} = require('models 폴더 경로');
User.findAll({
    attributes : ['name', 'age'],
    where : {
        married : 1,
        age : {[Op.gt] : 30},
    },
});
```
위처럼 where 옵션을 달 수도 있다.

age에 조금 특별한 연산이 사용되었는데, 자바스크립트 객체를 사용해서 쿼리를 생성해야 하므로 사용되는 특수한 연산자이다.
1. Op . gt : 초과
2. Op . gte : 이상
3. Op . lt : 미만
4. Op . lte : 이하
5. Op . ne : 같지 않음
6. Op . or : 또는
7. Op . in : 배열 요소 중 하나
8. Op . notIn : 배열 요소와 모두 다름

예제로 Op . or을 사용해보자.

SELECT id, name FROM users WHERE married = 0 OR age > 30;

```javascript
const {User, Sequelize : {Op}} = require('models 폴더 경로');
User.findAll({
    attributes : ['id', 'name'],
    where : {
        [Op.or] : [{married : 0}, {age : {[Op.gt] : 30}}]+,
    },
});
```
위처럼 Op . or 속성에 OR 연산을 적용할 쿼리들을 배열로 나열하면 된다.

정렬은 아래와 같이 한다.

SELECT id, name FROM users ORDER BY age DESC;

```javascript
User.findAll({
    attributes : ['id', 'name'],
    order : [['age', 'DESC']],
});
```
위처럼 order 옵션으로 정렬이 가능하다. 배열 안에 배열이 있는 이유는 컬럼 하나가 아닌 두 개 이상으로 정렬을 할 수도 있기 때문이다.

다음은 조회할 RAW의 개수를 설정하는 방법이다.

SELECT id, name FROM users ORDER BY age DESC LIMIT 1;

```javascript
User.findAll({
    attributes : ['id', 'name'],
    order : ['age', 'DESC'],
    limit : 1,
    offset : 1,
});
```
위의 코드는 find를 사용해도 되지만, findAll의 limit 옵션을 사용할 수도 있다. OFFSET도 offset 옵션으로 구현할 수 있다.

# UPDATE
update 메소드로 수정을 할 수 있다.

첫 번째 인자는 수정할 내용이고, 두 번째 인자는 수정 대상 RAW를 찾는 조건이다.

UPDATE nodejs.users SET comment = '바꿀 내용' WHERE id = 2;

```javascript
User.update({
    comment : '바꿀 내용',
}, {
    where : {id : 2},
});
```
# DELETE
destroy 메소드로 삭제할 수 있다.

DELETE FROM nodejs.users WHERE id = 2;

```javascript
User.destroy({
    where : {id : 2},
});