---
layout : post
title : passport-local 모듈
subtitle : 로컬 로그인 구현하기
categories : development
tags : nodejs
comments : false
---

# passport-local 모듈로 로컬 로그인 구현하기
로컬 로그인이란 다른 SNS 서비스를 통해서 로그인하는 것이 아닌 자체적인 회원가입 후 로그인하는 것을 의미한다. passport-local 모듈을 통해서 passport에서 로컬 로그인을 구현할 수 있다.

회원가입, 로그인, 로그아웃 라우터를 만들어야 하는데, 각각의 라우터에는 접근 조건이 필요하다. 로그인한 사용자는 회원가입과 로그인 라우터에 접근하면 안된다. 따라서 접근 권한을 제어하는 미들웨어가 필요하다.

```javascript
//routes/middlewares.js
exports.isLoggedIn = (req, res, next) => {
    if (req.isAuthenticated()) {
        next();
    } else {
        res.status(403).send('로그인 필요');
    }
};

exports.isNotLoggedIn = (req, res, next) => {
    if (!req.isAuthenticated()) {
        next();
    } else {
        res.redirect('/');
    }
};
```
passport는 req 객체에 isAuthenticated 메소드를 추가한다. 로그인 중이면 req.isAuthentificated() 가 true이고, 아니면 false 이다. 따라서 로그인 여부를 위처럼 메소드로 파악할 수 있다.

이제 isLoggedIn, isNotLoggedIn 미들웨어가 page 라우터에서 어떻게 사용되는지 보자.
```javascript
//routes/page.js
const express = require('express');
const {isLoggedIn, isNotLoggedIn} = require('./middlewares');

const router = express.Router();

router.get('/profile', isLoggedIn, (req, res) => {
    res.render('profile', {title : '내 정보 - NodeBird', user : req.user});
});

router.get('/join', isNotLoggedIn, (req, res) => {
    res.render('join', {
        title : '회원가입 - NodeBird',
        user : req.user,
        joinError : req.flash('joinError'),
    });
});

router.get('/', (req, res, next) => {
    res.render('main', {
        title : 'NodeBird',
        twits : [],
        user : req.user,
        loginError : req.flash('loginError'),
    });
});

module.exports = router;
```
1. 자신의 프로필은 로그인을 해야 볼 수 있으므로 isLoggedIn 미들웨어를 중간에 넣어주었다.로그인 상태여야만 next()가 호출되어서 res.render가 있는 미들웨어로 넘어가게 된다.

2. 회원가입 페이지는 로그인 상태가 아닌 사람에게만 보여야 하므로 isNotLoggedIn 미들웨어를 넣어주었다. 즉, 로그인 상태가 아닐 때만 다음 미들웨어로 넘어가게 된다.

팔로잉 여부, 관리자 여부 등의 미들웨어를 만들어서 응용 가능하다.

```javascript
//routes/auth.js
const express = require('express');
const passport = require('passport');
const bcrypt = require('bcrypt');
const {isLoggedIn, isNotLoggedIn} = require('./middlewares');
const {User} = require('../models');

const router = express.Router();
router.post('/join', isNotLoggedIn, async (req, res, next) => {
    const {email, nick, password} = req.body;
    try {
        if (exUser) {
            req.flash('joinError', '이미 가입된 이메일입니다.');
            return res.redirect('/join');
        }
        const hash = await bcrypt.hash(passoword, 12);
        await User.create({
            email,
            nick,
            passowrd : hash,
        });
        return res.redirect('/');
    } catch (err) {
        console.error(err);
        return next(err);
    }
});
router.post('/login', isNotLoggedIn, (req, res, next) => {
    passport.authenticate('local', (authError, user, info) => {
        if (authError) {
            console.error(authError);
            return next(authError);
        }
        if (!user) {
            req.flash('loginError', info.message);
            return res.redirect('/');
        }
        return req.login(user, (loginError) => {
            if (loginError) {
                console.error(loginError);
                return next(loginError);
            }
            return res.redirect('/');
        });
    })(req, res, next);
});
router.get('/logout', isLoggedIn, (req, res) => {
    req.logout();
    req.session.destroy();
    res.redirect('/');
});
module.exports = router;
```

1. 회원가입 라우터는 이미 가입된 이메일인지를 체크하고, 있다면 flash 메시지를 설정하여 회원가입 페이지로 되돌려보낸다. 없다면 bcrypt 모듈을 이용해서 비밀번호를 암호화하고, 사용자 정보를 생성한다.

2. 로그인 라우터에서는 passport.authenticate('local') 미들웨어가 로컬 로그인 전략을 수행한다. 미들웨어인데 미들웨어 안에 들어있다. 사용자 정의 기능을 추가할 때 보통 이렇게 한다고 한다. 이럴 때는 내부 미들웨어에 (req, res, next) 를 인자로 제공해서 호출하면 된다.

3. 로그아웃 라우터에서 req.logout 메소드는 req.user 객체를 제거하고, req.session.destroy 는 req.session 객체의 내용을 제거한다. 세션 정보를 지운 후 메인페이지로 돌아가게 된다.

```javascript
//passport/localStrategy.js
const LocalStrategy = require('passport-local').Strategy;
const bcrypt = require('bcrypt');

const {User} = require('../models');

module.exports = (passport) => {
    passport.use(new LocalStrategy({
        usernameField : 'email',
        passwordField : 'password',
    }, async (email, password, done) => {
        try {
            const exUser = await User.find({where : {email}});
            if (exUser) {
                const result = await bcrypt.compare(password, exUser.password);
                if (result) {
                    done(null, exUser);
                } else {
                    done(null, false, {message : '비밀번호가 일치하지 않습니다.'});
                }
            } else {
                done(null, false, {message : '가입되지 않은 회원입니다.'});
            }
        } catch (err) {
            console.error(err);
            done(err);
        }
    }));
};
```
1. LocalStrategy의 첫 번째 인자 : 전략에 관한 설정을 하는 곳이다. usernameField 와 passwordField 에는 일치하는 req.body 의 속성명을 적어주면 된다. req.body.email 에 이메일이, req.body.passport 에 비밀번호가 담겨 들어오므로 각각 'email', 'password'를 넣어줬다.

2. LocalStrategy의 두 번째 인자 : 실제 전략을 수행하는 async 함수이다. 위에서 넣어준 email과 password는 각각 async 함수의 첫 번째, 두 번째 인자가 된다. 세 번째 매개변수는 passport.authenticate의 콜백 함수이다.

먼저 사용자 DB에서 이메일을 찾고, 있다면 bcrypt의 compare 메소드로 비밀번호를 비교한다. 비밀번호까지 일치한다면 done 함수의 두 번째 인자로 사용자 정보를 넣어 보낸다.

#### done과 authenticate의 관계
1. 로그인 성공 시
```javascript
done(null, exUser);
passport.authenticate('local', authError, user, info);
```
    done 함수에 넘긴 null, exUser 는 각각 passport.authenticate의 authError, user 로 넘어가게 된다.

2. 로그인 실패 시
```javascript
done(null, false, {message : '비밀번호가 일치하지 않습니다.'});
passport.authenticate('local', authError, user, info);
```
    done 함수에 넘긴 null, false, message 는 각각 passport.authenticate의 authError, user, info 로 넘어가게 된다.

3. 서버 에러 시
```javascript
done(error);
passport.authenticate('local', authError, user, info);
```
    done 함수에 넘긴 error 는 passport.authenticate의 authError 로 넘어가게 된다.